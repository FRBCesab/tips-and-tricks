{
  "hash": "55ad2041d06fbc9bb625c27fb833b4f8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Occupancy models in R\"\nauthor: \"Lisa Nicvert\"\ndate: \"2026-01-06\"\ncategories: [r, statistics, occupancy]\nimage: \"\"\ntoc: true\ndraft: false\nlightbox: true\ncode-overflow: scroll\nbibliography: references.bib\n---\n\n> Question. Why do we talk out loud when we know we're alone? Conjecture. Because we know we're not.\n>\n> -- *The Twelfth Doctor, Doctor Who (Series 8, Episode 4: \"Listen\")*\n\n\n## Introduction\n\nIt's not because we didn't see something that this thing wasn't present. At least, that's the idea behind occupancy models: our observations aren't a direct representation of reality, but merely of what we can detect.\n\n![Present ($z_i = 1$), but not detected ($y_{ij} = 0$). _Photo by Caroline Kirk ([source](https://www.independent.co.uk/news/uk/wildlife-photographer-owl-camera-image-b1818585.html))_](bird.png)\n\nOccupancy models were first published by @mackenzie2002 in the context of species occurrence modelling. Many extensions of occupancy have been proposed since, allowing to explicitly model occupancy dynamics [@mackenzie_estimating_2003], take into account multiple species [@rota_multispecies_2016] or a continuous detection process [@mackenzie_estimating_2003]. This blog post only goes over the original simple occupancy model.\n\n## Simple occupancy model\n\n![Summary diagram of the structure of an occupancy model.](diagram.png){width=80%}\n\nTo discriminate between the real and the observed states, occupancy models have one parameter for each of these states. The *true* presence or absence of a species in a given site $i$ is noted $z_i$. The *observed* presence or absence at site $i$ for a given visit $j$ is noted $y_{ij}$. \n\nThen, the occupancy model for a given site $i$ is written as:\n\n$$\ny_{ij} \\sim Bern(z_i~p)\n$$ \n\n- if the species is really present in site $i$ ($z_i = 1$), then it is detected ($y_{ij} = 1$) with probability $p$ according to a Bernoulli trial. \n- if the species is absent in site $i$ ($z_i = 0$), then we assume that it cannot be detected ($y_{ij}$ has to be zero) (no false detection).\n\nIn the occupancy framework, $z_i$ itself is governed by a Bernoulli trial of probability $\\psi$.\n\n$$\nz_i \\sim Bern(\\psi)\n$$ \n\n$\\psi$ is called the *occupancy probability*: most of the times, when dealing with occupancy, that's the quantity we're really interested in.\n\n## Simulate occupancy\n\nOccupancy models are really easy to simulate: here is a sample R code to simulate data under a simple occupancy model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\n\nM <- 100 # Number of sites\np <- 0.4 # Detection probability\npsi <- 0.8 # Occupancy\n\n# Simulate a number of visits for each site\nnvisit <- rpois(n = M, lambda = 3)\nnvisit[nvisit == 0] <- 1 # Don't allow zero visits\n\n# Initialize vectors\nz <- vector(mode = \"numeric\", length = M)\ny <- vector(mode = \"list\", length = M)\n\nfor (i in 1:M) { # For each site\n  # Simulate true presence/absence at site i\n  zi <- rbinom(n = 1, size = 1, prob = psi)\n  \n  # Simulate observed presence/absence at site i for all visits\n  yij <- rbinom(n = nvisit[i], \n                size = 1, prob = p*zi)\n  \n  z[i] <- zi # True sites states\n  y[[i]] <- yij # Detections\n}\n```\n:::\n\n\nIn this simulation, the true proportion of occupied sites is 0.73. It is very close to the occupancy parameter $\\psi = 0.8$ (but it is not _exactly_ equal because of the stochastic nature of our model).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# True proportion of occupied sites\nsum(z)/M\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.73\n```\n\n\n:::\n:::\n\n\nThe proportion of sites that we *detect* as occupied (what is called the *naive occupancy*)  is 0.51, which wildly under-estimates $\\psi$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Proportion of sites with at least one detection\nsum(sapply(y, function(yi) any(yi != 0)))/M\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.51\n```\n\n\n:::\n:::\n\n\n## Infer occupancy models in R\n\nNow, the true value of occupancy models lies in the analysis of species detections. Inferring parameters from data is possible under three main conditions:\n\n-   You have repeated visits. This is an crucial point which allows parameter identifiability.\n-   The site remains in the same state (occupied or unoccupied) during the entire study period (closure assumption)[^1].\n-   There are no false detections. The model automatically assumes that a detection event means that the site is really occupied, and false detections might induce a positive bias in occupancy estimates.\n\n[^1]: In practice, this assumption is often violated in studies using occupancy models: this has been discussed extensively in the literature (see for example @valente2024), and authors have proposed to critically evaluate whether the closure assumption is met to interpret the inferred occupancy.\n\nThere are lots of strategies to infer occupancy models in R: among the most popular occupancy packages are `unmarked` and `spOccupancy`. Many people will also use Bayesian softwares like `JAGS` (e.g. with the R package `jagsUI` or `rjags`), `nimble` or Stan (with the R packages`cmdstanr`or`rstan`).\n\nThis blog post focuses on two of them: `unmarked` and Stan (using the R interface package `cmdstanr`).\n\n### `unmarked`\n\nThe R package [`unmarked`](https://rbchan.github.io/unmarked/) has functions  specifically designed for occupancy inference in R using maximum likelihood estimation (frequentist statistics).\n\nFirst, we have to format the observed visits to an `unmarkedFrameOccu` object, as exemplified below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(unmarked)\n\n# Format the list of observed detections y\nmax_visit <- max(sapply(y, length)) # Get maximum number of detections\n\n# Transform y to matrix\ny_matrix <- matrix(data = NA,\n                   nrow = M,\n                   ncol = max_visit)\nfor (i in 1:M) { # For each site\n  nvisit_i <- length(y[[i]]) # Get number of visits\n  y_matrix[i, 1:nvisit_i] <- y[[i]] # Fill n-th first rows with detection history\n}\n\n# Each row contains the detections at a site, filled with NAs for \n# sites that have less visits than the most visited one\nhead(y_matrix, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]\n[1,]    0    0    0    1    1   NA   NA   NA\n[2,]    1    0    0    1    1    1   NA   NA\n[3,]    0    0   NA   NA   NA   NA   NA   NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# Cast y_matrix to unmarkedFrameOccu\ny_occu <- unmarked::unmarkedFrameOccu(y_matrix)\nhead(y_occu, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nData frame representation of unmarkedFrame object.\n  y.1 y.2 y.3 y.4 y.5 y.6 y.7 y.8\n1   0   0   0   1   1  NA  NA  NA\n2   1   0   0   1   1   1  NA  NA\n3   0   0  NA  NA  NA  NA  NA  NA\n```\n\n\n:::\n:::\n\n\nIn `unmarked`, the main function to infer parameters of a simpler occupancy model is `occu`, which uses a maximum likelihood estimator. In its simplest form, it only needs two arguments: \n\n- `formula`, which gives the formulas for the logit of $p$ and $\\psi$. Here, since occupancy and detection are constant, we will set them to `~1 ~1`.\n- `data`: an `unmarkedFrameOccu` object containing observed detections (here, `y_occu`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Infer occupancy\nocc <- unmarked::occu(formula = ~1 ~1, \n                      data = y_occu)\n\nclass(occ)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"unmarkedFitOccu\"\nattr(,\"package\")\n[1] \"unmarked\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(occ)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nunmarked::occu(formula = ~1 ~ 1, data = y_occu)\n\nOccupancy (logit-scale):\n Estimate    SE    z P(>|z|)\n     1.03 0.406 2.54  0.0112\n\nDetection (logit-scale):\n Estimate    SE     z  P(>|z|)\n   -0.623 0.184 -3.38 0.000722\n\nAIC: 360.8983 \nNumber of sites: 100\n```\n\n\n:::\n:::\n\nThe output of the model is an `unmarkedFitOccu` object. The summary gives us the parameter estimates on the logit scale (i.e. we get $\\text{logit}(p)$ and $\\text{logit}(\\psi)$), but we can get estimates on the natural scale with `backTransform`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get detection (p) on the natural scale\nunmarked::backTransform(occ, type = \"det\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBacktransformed linear combination(s) of Detection estimate(s)\n\n Estimate     SE LinComb (Intercept)\n    0.349 0.0419  -0.623           1\n\nTransformation: logistic \n```\n\n\n:::\n\n```{.r .cell-code}\n# Get occupancy (state parameter, psi) on the natural scale\nunmarked::backTransform(occ, type = \"state\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBacktransformed linear combination(s) of Occupancy estimate(s)\n\n Estimate     SE LinComb (Intercept)\n    0.737 0.0788    1.03           1\n\nTransformation: logistic \n```\n\n\n:::\n:::\n\n\nAnd inferred parameters are a good approximation of true values (see figure below).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(ggplot2)\n\np_inf <- unmarked::predict(occ, \n                           type = \"det\",\n                           backTransform = TRUE,\n                           newdata = data.frame(1))\npsi_inf <- unmarked::predict(occ, \n                             type = \"state\",\n                             backTransform = TRUE,\n                             newdata = data.frame(1))\n\numk_param_df <- data.frame(param = c(\"p\", \"p\", \"psi\", \"psi\"),\n                           type = c(\"inferred\", \"true\", \"inferred\", \"true\"),\n                           estimate = c(p_inf$Predicted, p,\n                                        psi_inf$Predicted, psi),\n                           min = c(p_inf$lower, NA,\n                                   psi_inf$lower, NA),\n                           max = c(p_inf$upper, NA,\n                                   psi_inf$upper, NA))\n\nggplot(umk_param_df) +\n  geom_errorbar(data = subset(umk_param_df, type == \"inferred\"),\n                aes(xmin = min, xmax = max, y = param,\n                    color = type)) +\n  geom_point(aes(x = estimate, y = param,\n                 color = type)) +\n  theme_bw(base_size = 15) +\n  xlim(0, 1) +\n  theme(axis.title = element_blank()) +\n  ggtitle(\"True and inferred occupancy parameters with unmarked\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n### Stan\n\nBayesian frameworks are also quite common to infer occupancy models, notably because they allow for more flexibility in the parameters specifications.\nHere, we use [Stan](https://mc-stan.org/) through the R package [`cmdstanr`](https://mc-stan.org/cmdstanr/). Stan is a Bayesian software using optimized algorithms for the MCMC samplers. \n\n\nIn Stan, it is more efficient to use a Binomial model specification: we model the _number of detections_ $n_i$ at each site:\n\n$$n_i \\sim Binom({n_{\\text{visit}}}_i, z_i~p) \\quad \\text{and} \\quad z_i \\sim Bern(\\psi)$$\nwhere ${n_{\\text{visit}}}_i$ the number of visits at site $i$. The equations above are strictly equivalent to the general occupancy model specification described earlier.\n\nThe first step is to format our data to be used by Stan. For that, we aggregate our visits to total number of detections, and save data parameters to a list named `dat`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Format data for Stan\nn <- sapply(y, sum) # Number of detections\nnvisit <- sapply(y, length) # Number of visits\n\n# List of parameters for Stan\ndat <- list(M = M,\n            n = n,\n            nvisit = nvisit)\n```\n:::\n\n\n#### Stan code\nThen, we write the Stan code to infer our occupancy parameters. Stan is a programming language in its own right, and here we will only go over the Stan syntax quickly.\n\nStan programs are organized in code blocks, which are indicated by opening and closing brackets as shown below:\n\n```stan\ndata {\n  // Code block to define data variables\n}\n\nparameters {\n  // Code block to define parameters\n}\n\nmodel {\n  // Code block to infer parameters\n}\n```\nNote that Stan comments are specified with a double backslash `//`.\nThere are other optional code blocks (in fact, we will use one later), but the mandatory ones are shown above. \n\n\nLet's start by defining variables in the data block. Stan variables are typed (i.e. we must define their type manually with the statements before variables names). Here, we only need the 3 variables that we specified on our data list above.\n```stan\ndata {\n  int<lower=1> M; // Number of sites\n  array[M] int nvisit; // Number of visits per sites-years\n  array[M] int<lower=0> n; // Observations vector\n}\n```\n\nNext, we define the parameters we want to infer in the parameters block. Here, they are defined on the logit scale because inferring unbounded parameters is more efficient in Stan.\n```stan\nparameters {\n  real psi_logit; // Value of psi on the logit scale\n  real p_logit; // Value of p on the logit scale\n}\n```\n\nThe syntax of the model block is slightly more complex. There are 3 steps:\n\n- Define the parameters priors: here, we use flat normal priors centered on zero with a standard deviation of 3. This amounts to initializing the log-posterior with a log-transformed normal density, which is what `target += normal_lpdf(param | 0, 3)` does.\n- (Optional) Define intermediate variables. Here, we define `nvi` as a shortcut for the number of visits for site $i$.\n- Specify the model. This is where it requires a bit of work, because Stan cannot model discrete variables, so we have to update the posterior probability density manually instead. Fortunately, it is fairly easy to write with respect to $p$ and $\\psi$. Here, we won't go into the details of these computations (but see @nte-posterior below).\n\n```stan\nmodel {\n  // 1. Priors\n  target += normal_lpdf(psi_logit | 0, 3);\n  target += normal_lpdf(p_logit | 0, 3);\n\n  // 2. Variables\n  int nvi;\n\n  // 3. Model specification\n  for (i in 1:M) { // Iterate over sites\n    nvi = nvisit[i]; // Number of visits\n    if (n[i] > 0) { // The species was seen\n      // Update log-likelihood: species was detected | present\n      target += log_inv_logit(psi_logit) + \n        binomial_logit_lpmf(n[i] | nvi, p_logit);\n    } else {\n      // Update log-likelihood: species was non-detected | present\n      // or non-detected | absent\n      target += log_sum_exp(log_inv_logit(psi_logit) + binomial_logit_lpmf(0 | nvi, p_logit), \n        log1m_inv_logit(psi_logit));\n    }\n  }\n}\n```\n\n::: {#nte-posterior .callout-note title=\"Log-posterior probability density computation\"}\nBelow, we give a bit more explanations about the computation of the log-posterior.\n\nWe distinguish between two cases to write the log-posterior:\n\n- The species was detected at least once (case `n[i] > 0`). In that case, we know that it was present (no false detections), so the conditional log-probability that the species was seen $n_i$ times (which is what we update `target` with) is the product of the occupancy probability $\\psi$ and the binomial density probability of $N = n$: \n$$P(N = n_i | \\{p, \\psi\\}) = \\psi ~ \\underbrace{\\binom{{n_{\\text{visit}}}_i}{n_i} p^{n_i} p^{{n_{\\text{visit}}}_i - n_i}}_{\\text{Binomial density probability}}$$\nIn Stan, parameters are on the logit scale: `psi_logit` is first back-transformed with `log_inv_logit` and Stan uses the Binomial density probability on the logit scale with `binomial_logit_lpmf`. Finally, because we compute the log-posterior, by properties of the logarithm the multiplication is changed to an addition.\n\n- When the species was not seen (`else` block), we have two options. Either the species was present, but undetected; or it was absent. In that case, the conditional log-probability is the sum of these two events:\n$$P(N = 0 | \\{p, \\psi\\}) = \\underbrace{\\psi ~ \\binom{{n_{\\text{visit}}}_i}{0} p^{0} p^{{n_{\\text{visit}}}_i - 0}}_{\\text{present, undetected}} + \\underbrace{(1 - \\psi)}_{\\text{absent}}$$\nIn Stan, `log_sum_exp` is an efficient way to compute a logarithm of the sum above, and `log1m_inv_logit(psi_logit)` returns $1 - \\psi$.\n\nMore details on log-likelihood computation can be found in [this blog post](https://htmlpreview.github.io/?https://github.com/bbennie/StanOccupancyModelTutorials/blob/master/OccupancyStanIntroduction.html) or in chapter 2.4.6 of @kery_applied_2016.\n:::\n\nThe final (and optional) code block we use here is a generated quantities block. It allows to compute $p$ and $\\psi$ on the natural scale by using `inv_logit` to back-transform parameters.\n```stan\ngenerated quantities {\n  real<lower=0,upper=1> p = inv_logit(p_logit);\n  real<lower=0, upper=1> psi = inv_logit(psi_logit);\n}\n```\n\nThe final Stan code is summarised below:\n```stan\ndata {\n  int<lower=1> M; // Number of sites\n  array[M] int nvisit; // Number of visits per sites-years\n  array[M] int<lower=0> n; // Observations vector\n}\n\nparameters {\n  real psi_logit; // Value of psi on the logit scale\n  real p_logit; // Value of p on the logit scale\n}\n\nmodel {\n  // 1. Priors\n  target += normal_lpdf(psi_logit | 0, 3);\n  target += normal_lpdf(p_logit | 0, 3);\n\n  // 2. Variables\n  int nvi;\n\n  // 3. Model specification\n  for (i in 1:M) { // Iterate over sites\n    nvi = nvisit[i]; // Number of visits\n    if (n[i] > 0) { // The species was seen\n      // Update log-likelihood: species was detected | present\n      target += log_inv_logit(psi_logit) + binomial_logit_lpmf(n[i] | nvi, p_logit);\n    } else {\n      // Update log-likelihood: species was non-detected | present\n      // or non-detected | absent\n      target += log_sum_exp(log_inv_logit(psi_logit) + binomial_logit_lpmf(0 | nvi, p_logit), log1m_inv_logit(psi_logit));\n    }\n  }\n}\n\ngenerated quantities {\n  real<lower=0,upper=1> p = inv_logit(p_logit);\n  real<lower=0, upper=1> psi = inv_logit(psi_logit);\n}\n```\n\n#### Inference with `cmdstanr`\n\n\n::: {.cell}\n\n:::\n\n\nNow, we can use this code to infer our occupancy parameters from R. The first step is to compile the Stan model using `cmdstan_model`, as shown in the code below. Here, we assume the Stan code above is written in a file, which path is stored in the `stan_file` variable in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(cmdstanr)\n\nmodel <- cmdstanr::cmdstan_model(stan_file = stan_file)\n```\n:::\n\n\nWe can finally perform the inference on our `model` object, with the `$sample` method from the `CmdStanModel` class. \nThe `$sample` method can be customised with many arguments, but here we only use our data list (`data`), the number of burn-in iterations (`warmup`), the number of post-burn-in iterations (`iter_sampling`) and the number of chains and their parallelisation (`chains` and `parallel_chains`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstanfit <- model$sample(data = dat,\n                        iter_warmup = 200,\n                        iter_sampling = 500,\n                        chains = 4,\n                        parallel_chains = 4)\n```\n:::\n\n\nWe can inspect the inferred values with the `$summary` method. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n(stan_inf <- stanfit$summary())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 10\n  variable      mean   median     sd    mad       q5      q95  rhat ess_bulk\n  <chr>        <dbl>    <dbl>  <dbl>  <dbl>    <dbl>    <dbl> <dbl>    <dbl>\n1 lp__      -115.    -114.    1.02   0.801  -117.    -114.     1.01     882.\n2 psi_logit    1.18     1.11  0.484  0.440     0.491    2.06   1.00    1011.\n3 p_logit     -0.651   -0.649 0.190  0.183    -0.970   -0.332  1.00     771.\n4 p            0.344    0.343 0.0427 0.0409    0.275    0.418  1.00     771.\n5 psi          0.754    0.753 0.0795 0.0808    0.620    0.887  1.00    1011.\n# ℹ 1 more variable: ess_tail <dbl>\n```\n\n\n:::\n:::\n\n\nThe summary gives information about the log-posterior (`lp__`) and all inferred parameters (on the logit and the natural scales).\nFor each parameter, a set of summary statistics which summarize their distribution are given. Three diagnostic parameters to evaluate MCMC sampling are also given (a convergence statistic $\\hat{R}$, and effective sample sizes (ESS)).\n\nFinally, a graphical summary shows that inferred parameters are close to the real ones:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(ggplot2)\n\nstan_param_df <- data.frame(param = c(\"p\", \"p\", \"psi\", \"psi\"),\n                            type = c(\"inferred\", \"true\", \"inferred\", \"true\"),\n                            estimate = c(stan_inf$mean[stan_inf$variable == \"p\"], p,\n                                         stan_inf$mean[stan_inf$variable == \"psi\"], psi),\n                            min = c(stan_inf$q5[stan_inf$variable == \"p\"], NA,\n                                    stan_inf$q5[stan_inf$variable == \"psi\"], NA),\n                            max = c(stan_inf$q95[stan_inf$variable == \"p\"], NA,\n                                    stan_inf$q95[stan_inf$variable == \"psi\"], NA))\n\nggplot(stan_param_df) +\n  geom_errorbar(data = subset(stan_param_df, type == \"inferred\"),\n                aes(xmin = min, xmax = max, y = param,\n                    color = type)) +\n  geom_point(aes(x = estimate, y = param,\n                 color = type)) +\n  theme_bw(base_size = 15) +\n  xlim(0, 1) +\n  theme(axis.title = element_blank()) +\n  ggtitle(\"True and inferred occupancy parameters with Stan\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n## Conclusion\nIn this blog post, we have seen how the simple occupancy model is written and how simulate data under an occupancy model in R. We have then inferred occupancy models with the `unmarked` and `cmdstanr` R packages.\n\nThere is much more one can do with occupancy models. In particular, the parameters $p$ and $\\psi$ are often not constant, and can be modeled as functions of covariates with a logit link, such as $\\text{logit}(\\psi_i) = \\beta_0 + \\beta_1 x_i$ or $\\text{logit}(p_{ij}) = \\beta_0 + \\beta_1 x_{ij}$. But this is a story for another blog post...\n\n## References\n::: {#refs}\n:::\n\n## Other resources\n\n- Richard A. Erickson's [GitHub repository](https://github.com/bbennie/StanOccupancyModelTutorials) with Stan occupancy models tutorials\n- Olivier Gimenez's [workshop](https://oliviergimenez.github.io/occupancy-workshop/) with resources on occupancy modelling with `unmarked`",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}