{
  "hash": "2abd9bdfd78e177803badcfe639e08aa",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The apply() function family\"\nauthor: \"Nicolas Casajus\"\ndate: \"2024-11-19\"\ncategories: [r, apply, lapply, tapply, recursive, function, loop]\nimage: \"\"\ntoc: true\ndraft: false\nlightbox: true\ncode-overflow: scroll\n---\n\nIn this post, we will discuss about the family of `apply()` functions. These functions allows you to recursively apply a function across all elements of a `vector`, `list`, `matrix`, or `data.frame`. The `apply()`\nfamily is an interesting alternative to the `for` loop because it wraps the loop into a simple function.\n\n\nThe functions in the `apply()` family differ in their input and output types:\n\n| Function                                         | Description                                                               |\n|:------------------------------------------------:|:--------------------------------------------------------------------------|\n| [`apply()`](https://rdrr.io/r/base/apply.html)   | Applies a function to **margins** of an `array`, `matrix` or `data.frame` (2D objects) |\n| [`lapply()`](https://rdrr.io/r/base/lapply.html) | Applies a function over a `list` or `vector` and returns a `list`         |\n| [`sapply()`](https://rdrr.io/r/base/lapply.html) | Wrapper of `lapply` but returns a `vector` or `matrix` (volatile)         |\n| [`vapply()`](https://rdrr.io/r/base/lapply.html) | Similar to `sapply` but safer                                             |\n| [`tapply()`](https://rdrr.io/r/base/tapply.html) | Applies a function to a **group** of data grouped by one or more factors and returns an `array`          |\n\n<br/>\n\n**NB.** Here we won't talk about `sapply()` and `vapply()` as there are similar to `lapply()`.\n\n\n<br/>\n\n\n\n## Dataset\n\nTo illustrate to use of `apply()` functions, we will use the [`palmerpenguins`](https://allisonhorst.github.io/palmerpenguins/articles/intro.html) package. It contains the `penguins` dataset with size measurements for three penguin species observed on three islands in the Palmer Archipelago, Antarctica.\n\n![Atwork by [Allison Horst](https://allisonhorst.com/)](palmer-penguins.png){width=60%}\n\n> These data were collected from 2007 and 2009 by Dr. Kristen Gorman and are released under the [CC0](https://creativecommons.org/public-domain/cc0/) license.\n\n\n<br/>\n\n\nLet's install the released version of [`palmerpenguins`](https://allisonhorst.github.io/palmerpenguins/) package from [CRAN](https://cran.r-project.org/):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Install 'palmerpenguins' package ----\ninstall.packages(\"palmerpenguins\")\n```\n:::\n\n\n\nNow, let's import the dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Import 'penguins' dataset ----\nlibrary(\"palmerpenguins\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'palmerpenguins'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:datasets':\n\n    penguins, penguins_raw\n```\n\n\n:::\n\n```{.r .cell-code}\npenguins\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n\n\n:::\n:::\n\n\nFor this post, we will use a subset of this dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Columns to keep ----\ncols <- c(\"species\", \"island\", \"bill_length_mm\", \"bill_depth_mm\", \n          \"body_mass_g\")\n\n## Subset data ----\npenguins <- penguins[ , cols]\npenguins\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 5\n   species island    bill_length_mm bill_depth_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>       <int>\n 1 Adelie  Torgersen           39.1          18.7        3750\n 2 Adelie  Torgersen           39.5          17.4        3800\n 3 Adelie  Torgersen           40.3          18          3250\n 4 Adelie  Torgersen           NA            NA            NA\n 5 Adelie  Torgersen           36.7          19.3        3450\n 6 Adelie  Torgersen           39.3          20.6        3650\n 7 Adelie  Torgersen           38.9          17.8        3625\n 8 Adelie  Torgersen           39.2          19.6        4675\n 9 Adelie  Torgersen           34.1          18.1        3475\n10 Adelie  Torgersen           42            20.2        4250\n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n\n\n\n## The `apply()` function\n\nThe `apply()` lets you perform a function across rows or columns of a `data.frame` (or any types of 2-dimension objects).\n\n- the first argument `X` specifies the data\n- the second argument `MARGIN` specifies the direction (`1` for rows, `2` for columns)\n- the third argument `FUN` is the function to apply\n\nLet's compute the arithmetic mean of the columns `bill_length_mm`, `bill_depth_mm` and `body_mass_g` by applying the `mean()` function **across columns** 3 to 5 of the `penguins` dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Mean of columns 3, 4 and 5 ----\napply(penguins[ , 3:5], 2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbill_length_mm  bill_depth_mm    body_mass_g \n            NA             NA             NA \n```\n\n\n:::\n:::\n\n\nWe can pass arguments to the function `mean()` by using the argument `...` of the function `apply()`. Let's remove missing values before computing the mean.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Use additional arguments ----\napply(penguins[ , 3:5], 2, mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbill_length_mm  bill_depth_mm    body_mass_g \n      43.92193       17.15117     4201.75439 \n```\n\n\n:::\n:::\n\n\nNote that the `apply()` functions are pipe-friendly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Pipe version ----\npenguins[ , 3:5] |> \n  apply(2, mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbill_length_mm  bill_depth_mm    body_mass_g \n      43.92193       17.15117     4201.75439 \n```\n\n\n:::\n:::\n\n\nWe can also use a custom function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Custom function ----\napply(penguins[ , 3:5], 2, function(x) mean(x, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbill_length_mm  bill_depth_mm    body_mass_g \n      43.92193       17.15117     4201.75439 \n```\n\n\n:::\n:::\n\n\nFinally, we can define a custom function outside the `apply()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Custom function ----\nmy_mean <- function(x, na_rm = FALSE) {\n  mean(x, na.rm = na_rm)\n}\n\napply(penguins[ , 3:5], 2, my_mean, na_rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbill_length_mm  bill_depth_mm    body_mass_g \n      43.92193       17.15117     4201.75439 \n```\n\n\n:::\n:::\n\n\n\nThe output is a vector, but in some cases it can be a `matrix` (or an `array`).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Different output class ----\napply(penguins[ , 3:5], 2, range, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     bill_length_mm bill_depth_mm body_mass_g\n[1,]           32.1          13.1        2700\n[2,]           59.6          21.5        6300\n```\n\n\n:::\n:::\n\n\n\n<br/>\n\n## The `lapply()` function\n\nThe `lapply()` function performs a function on each element of a `list` or `vector`.\n\n- the first argument `X` specifies the `list` or the `vector`\n- the second argument `FUN` is the function to apply\n\nLet's try to compute the arithmetic mean of the columns `bill_length_mm`, `bill_depth_mm` and `body_mass_g`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Column names ----\ncolumns <- c(\"bill_length_mm\", \"bill_depth_mm\", \"body_mass_g\")\n\n## Mean of columns 3, 4 and 5 ----\nlapply(columns, function(x) {\n  penguins[ , x, drop = TRUE] |> \n    mean(na.rm = TRUE)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 43.92193\n\n[[2]]\n[1] 17.15117\n\n[[3]]\n[1] 4201.754\n```\n\n\n:::\n:::\n\n\nThe output is a `list` of same length as `X`, and we can simplified it by using `unlist()`. We can do this because the output for each iteration is a single value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Column names ----\ncolumns <- c(\"bill_length_mm\", \"bill_depth_mm\", \"body_mass_g\")\n\n## Mean of columns 3, 4 and 5 ----\nvalues <- lapply(columns, function(x) {\n  penguins[ , x, drop = TRUE] |> \n    mean(na.rm = TRUE)\n})\n\n## Simplify output ----\nunlist(values)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   43.92193   17.15117 4201.75439\n```\n\n\n:::\n:::\n\n\nAnd we can name values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Column names ----\ncolumns <- c(\"bill_length_mm\", \"bill_depth_mm\", \"body_mass_g\")\n\n## Mean of columns 3, 4 and 5 ----\nvalues <- lapply(columns, function(x) {\n  penguins[ , x, drop = TRUE] |> \n    mean(na.rm = TRUE)\n})\n\n## Simplify output ----\nvalues <- unlist(values)\n\n## Name elements ----\nnames(values) <- columns\n\nvalues\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbill_length_mm  bill_depth_mm    body_mass_g \n      43.92193       17.15117     4201.75439 \n```\n\n\n:::\n:::\n\n\n\nThe `lapply()` allows you to perform complex tasks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Column names ----\ncolumns <- c(\"bill_length_mm\", \"bill_depth_mm\", \"body_mass_g\")\n\n## Mean, min and max of columns 3, 4 and 5 ----\nvalues <- lapply(columns, function(x) {\n  column <- penguins[ , x, drop = TRUE]\n  data.frame(\"trait\" = x,\n             \"mean\"  = mean(column, na.rm = TRUE),\n             \"min\"   = min(column, na.rm = TRUE),\n             \"max\"   = max(column, na.rm = TRUE))\n})\n\nvalues\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n           trait     mean  min  max\n1 bill_length_mm 43.92193 32.1 59.6\n\n[[2]]\n          trait     mean  min  max\n1 bill_depth_mm 17.15117 13.1 21.5\n\n[[3]]\n        trait     mean  min  max\n1 body_mass_g 4201.754 2700 6300\n```\n\n\n:::\n:::\n\n\n\nLet's simplify the output into a single `data.frame` by recursively applying (with `do.call()`) the function `rbind.data.frame()` to each `data.frame` of the `list`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Simplify output ----\nvalues <- do.call(rbind.data.frame, values)\n\nvalues\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           trait       mean    min    max\n1 bill_length_mm   43.92193   32.1   59.6\n2  bill_depth_mm   17.15117   13.1   21.5\n3    body_mass_g 4201.75439 2700.0 6300.0\n```\n\n\n:::\n:::\n\n\n**NB.** Here the object `penguins` is retrieved from the global environment. But it's safer to explicitly use it like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Column names ----\ncolumns <- c(\"bill_length_mm\", \"bill_depth_mm\", \"body_mass_g\")\n\n## Mean, min and max of columns 3, 4 and 5 ----\nvalues <- lapply(columns, function(x, data) {\n  column <- data[ , x, drop = TRUE]\n  data.frame(\"trait\" = x,\n             \"mean\"  = mean(column, na.rm = TRUE),\n             \"min\"   = min(column, na.rm = TRUE),\n             \"max\"   = max(column, na.rm = TRUE))\n}, data = penguins)\n\ndo.call(rbind.data.frame, values)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           trait       mean    min    max\n1 bill_length_mm   43.92193   32.1   59.6\n2  bill_depth_mm   17.15117   13.1   21.5\n3    body_mass_g 4201.75439 2700.0 6300.0\n```\n\n\n:::\n:::\n\n\n\n<br/>\n\n\n## The `tapply()` function\n\nThe `tapply()` allows you to perform a function across specified groups in your data. For `dplyr` users, it's equivalent to the `group_by()` and `summarize()` functions.\n\n- the first argument `X` specifies the values\n- the second argument `INDEX` specifies the groups\n- the third argument `FUN` is the function to apply\n\nLets' compute the mean of `bill_length_mm` for each species.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Average bill length for each species ----\ntapply(penguins$\"bill_length_mm\", penguins$\"species\", function(x) {\n  mean(x, na.rm = TRUE)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Adelie Chinstrap    Gentoo \n 38.79139  48.83382  47.50488 \n```\n\n\n:::\n:::\n\n\nWe can group values according to two variables.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Average bill length for each species ----\ntapply(penguins$\"bill_length_mm\", \n       list(penguins$\"species\", penguins$\"island\"), \n       function(x) mean(x, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            Biscoe    Dream Torgersen\nAdelie    38.97500 38.50179  38.95098\nChinstrap       NA 48.83382        NA\nGentoo    47.50488       NA        NA\n```\n\n\n:::\n:::\n\n\nHere the output is a `matrix`. We can convert it to long `data.frame` w/ `tidyr::pivot_longer()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Load 'dplyr' package ----\nlibrary(\"tidyr\")\n\n## Average bill length for each species and island ----\nvalues <- tapply(penguins$\"bill_length_mm\", \n                 list(penguins$\"species\", penguins$\"island\"), \n                 function(x) mean(x, na.rm = TRUE))\n\n## Convert to data.frame ----\nvalues <- data.frame(values)\nvalues$\"species\" <- rownames(values)\n\n\n## Pivot data ----  \nvalues |> \n  pivot_longer(cols      = !species,\n               values_to = \"bill_length_mm\",\n               names_to  = \"island\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 3\n  species   island    bill_length_mm\n  <chr>     <chr>              <dbl>\n1 Adelie    Biscoe              39.0\n2 Adelie    Dream               38.5\n3 Adelie    Torgersen           39.0\n4 Chinstrap Biscoe              NA  \n5 Chinstrap Dream               48.8\n6 Chinstrap Torgersen           NA  \n7 Gentoo    Biscoe              47.5\n8 Gentoo    Dream               NA  \n9 Gentoo    Torgersen           NA  \n```\n\n\n:::\n:::\n\n\n\nThis is equivalent to `dplyr` approach.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Load 'dplyr' package ----\nlibrary(\"dplyr\")\n\n## Summarise data ----\npenguins %>%\n  group_by(species, island) %>%\n  summarize(bill_length_mm = mean(bill_length_mm, \n                                  na.rm = TRUE)) %>%\n  ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  species   island    bill_length_mm\n  <fct>     <fct>              <dbl>\n1 Adelie    Biscoe              39.0\n2 Adelie    Dream               38.5\n3 Adelie    Torgersen           39.0\n4 Chinstrap Dream               48.8\n5 Gentoo    Biscoe              47.5\n```\n\n\n:::\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}